 .../platform/fonts/win/font_cache_skia_win.cc      | 157 +--------------------
 1 file changed, 2 insertions(+), 155 deletions(-)

diff --git third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index b3e09a38bc17..770974bbdc0f 100644
--- third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -240,112 +240,7 @@ static inline bool DeprecatedEqualIgnoringCase(const AtomicString& a,
                                                const SkString& b) {
   return DeprecatedEqualIgnoringCase(a, ToAtomicString(b));
 }
-
-static bool TypefacesMatchesFamily(const SkTypeface* tf,
-                                   const AtomicString& family) {
-  SkTypeface::LocalizedStrings* actual_families =
-      tf->createFamilyNameIterator();
-  bool matches_requested_family = false;
-  SkTypeface::LocalizedString actual_family;
-
-  while (actual_families->next(&actual_family)) {
-    if (DeprecatedEqualIgnoringCase(family, actual_family.fString)) {
-      matches_requested_family = true;
-      break;
-    }
-  }
-  actual_families->unref();
-
-  // getFamilyName may return a name not returned by the
-  // createFamilyNameIterator.
-  // Specifically in cases where Windows substitutes the font based on the
-  // HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontSubstitutes registry
-  // entries.
-  if (!matches_requested_family) {
-    SkString family_name;
-    tf->getFamilyName(&family_name);
-    if (DeprecatedEqualIgnoringCase(family, family_name))
-      matches_requested_family = true;
-  }
-
-  return matches_requested_family;
-}
-
-static bool TypefacesHasWeightSuffix(const AtomicString& family,
-                                     AtomicString& adjusted_name,
-                                     FontSelectionValue& variant_weight) {
-  struct FamilyWeightSuffix {
-    const wchar_t* suffix;
-    size_t length;
-    FontSelectionValue weight;
-  };
-  // Mapping from suffix to weight from the DirectWrite documentation.
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/dd368082.aspx
-  const static FamilyWeightSuffix kVariantForSuffix[] = {
-      {L" thin", 5, FontSelectionValue(100)},
-      {L" extralight", 11, FontSelectionValue(200)},
-      {L" ultralight", 11, FontSelectionValue(200)},
-      {L" light", 6, FontSelectionValue(300)},
-      {L" regular", 8, FontSelectionValue(400)},
-      {L" medium", 7, FontSelectionValue(500)},
-      {L" demibold", 9, FontSelectionValue(600)},
-      {L" semibold", 9, FontSelectionValue(600)},
-      {L" extrabold", 10, FontSelectionValue(800)},
-      {L" ultrabold", 10, FontSelectionValue(800)},
-      {L" black", 6, FontSelectionValue(900)},
-      {L" heavy", 6, FontSelectionValue(900)}};
-  size_t num_variants = arraysize(kVariantForSuffix);
-  for (size_t i = 0; i < num_variants; i++) {
-    const FamilyWeightSuffix& entry = kVariantForSuffix[i];
-    if (family.EndsWith(entry.suffix, kTextCaseUnicodeInsensitive)) {
-      String family_name = family.GetString();
-      family_name.Truncate(family.length() - entry.length);
-      adjusted_name = AtomicString(family_name);
-      variant_weight = entry.weight;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-static bool TypefacesHasStretchSuffix(const AtomicString& family,
-                                      AtomicString& adjusted_name,
-                                      FontSelectionValue& variant_stretch) {
-  struct FamilyStretchSuffix {
-    const wchar_t* suffix;
-    size_t length;
-    FontSelectionValue stretch;
-  };
-  // Mapping from suffix to stretch value from the DirectWrite documentation.
-  // http://msdn.microsoft.com/en-us/library/windows/desktop/dd368078.aspx
-  // Also includes Narrow as a synonym for Condensed to to support Arial
-  // Narrow and other fonts following the same naming scheme.
-  const static FamilyStretchSuffix kVariantForSuffix[] = {
-      {L" ultracondensed", 15, UltraCondensedWidthValue()},
-      {L" extracondensed", 15, ExtraCondensedWidthValue()},
-      {L" condensed", 10, CondensedWidthValue()},
-      {L" narrow", 7, CondensedWidthValue()},
-      {L" semicondensed", 14, SemiCondensedWidthValue()},
-      {L" semiexpanded", 13, SemiExpandedWidthValue()},
-      {L" expanded", 9, ExpandedWidthValue()},
-      {L" extraexpanded", 14, ExtraExpandedWidthValue()},
-      {L" ultraexpanded", 14, UltraExpandedWidthValue()}};
-  size_t num_variants = arraysize(kVariantForSuffix);
-  for (size_t i = 0; i < num_variants; i++) {
-    const FamilyStretchSuffix& entry = kVariantForSuffix[i];
-    if (family.EndsWith(entry.suffix, kTextCaseUnicodeInsensitive)) {
-      String family_name = family.GetString();
-      family_name.Truncate(family.length() - entry.length);
-      adjusted_name = AtomicString(family_name);
-      variant_stretch = entry.stretch;
-      return true;
-    }
-  }
-
-  return false;
-}
-
+ 
 std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
     const FontDescription& font_description,
     const FontFaceCreationParams& creation_params,
@@ -356,57 +251,9 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
   CString name;
   sk_sp<SkTypeface> typeface =
       CreateTypeface(font_description, creation_params, name);
-  // Windows will always give us a valid pointer here, even if the face name
-  // is non-existent. We have to double-check and see if the family name was
-  // really used.
-  if (!typeface ||
-      !TypefacesMatchesFamily(typeface.get(), creation_params.Family())) {
-    AtomicString adjusted_name;
-    FontSelectionValue variant_weight;
-    FontSelectionValue variant_stretch;
-
-    // TODO: crbug.com/627143 LocalFontFaceSource.cpp, which implements
-    // retrieving src: local() font data uses getFontData, which in turn comes
-    // here, to retrieve fonts from the cache and specifies the argument to
-    // local() as family name. So we do not match by full font name or
-    // postscript name as the spec says:
-    // https://drafts.csswg.org/css-fonts-3/#src-desc
-
-    // Prevent one side effect of the suffix translation below where when
-    // matching local("Roboto Regular") it tries to find the closest match even
-    // though that can be a bold font in case of Roboto Bold.
-    if (alternate_font_name == AlternateFontName::kLocalUniqueFace) {
-      return nullptr;
-    }
 
-    if (alternate_font_name == AlternateFontName::kLastResort) {
-      if (!typeface)
-        return nullptr;
-    } else if (TypefacesHasWeightSuffix(creation_params.Family(), adjusted_name,
-                                        variant_weight)) {
-      FontFaceCreationParams adjusted_params(adjusted_name);
-      FontDescription adjusted_font_description = font_description;
-      adjusted_font_description.SetWeight(variant_weight);
-      typeface =
-          CreateTypeface(adjusted_font_description, adjusted_params, name);
-      if (!typeface || !TypefacesMatchesFamily(typeface.get(), adjusted_name)) {
-        return nullptr;
-      }
-
-    } else if (TypefacesHasStretchSuffix(creation_params.Family(),
-                                         adjusted_name, variant_stretch)) {
-      FontFaceCreationParams adjusted_params(adjusted_name);
-      FontDescription adjusted_font_description = font_description;
-      adjusted_font_description.SetStretch(variant_stretch);
-      typeface =
-          CreateTypeface(adjusted_font_description, adjusted_params, name);
-      if (!typeface || !TypefacesMatchesFamily(typeface.get(), adjusted_name)) {
-        return nullptr;
-      }
-    } else {
+  if (!typeface)
       return nullptr;
-    }
-  }
 
   std::unique_ptr<FontPlatformData> result = std::make_unique<FontPlatformData>(
       typeface, name.data(), font_size,
